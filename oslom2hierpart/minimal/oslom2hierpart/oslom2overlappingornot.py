import random
import glob
import os, os.path
import sys
import itertools # for the cartesian product
from utils import * # some utils, contained in this folder

if len(sys.argv)!=2:
    print("Usage:",sys.argv[0],"<edges file> [assuming <edges file>_oslo_files has already been generated]")
    quit()
else:
    edgesfilename=sys.argv[-1]

N,neighbors=getNneighbors(edgesfilename)
layerbasefilename=edgesfilename+"_oslom2overlappingornot_files/layer"

tpfolder=edgesfilename+"_oslo_files"
assert os.path.exists(tpfolder)
number_of_tp_files=len(glob.glob(tpfolder+"/tp*"))
number_of_layers=number_of_tp_files
# this is the list of layers, as generated by OSLOM2/oslo_undir
tpfiles=[tpfolder+'/tp']+[tpfolder+'/tp'+str(n) for n in range(1,number_of_tp_files)]

# create folder where outputs will be saved
#   (to be saved in modbp format, to make use of the code we have already written, that takes it to nsp format)
layerfolder=edgesfilename+"_oslom2overlappingornot_files"
if not os.path.exists(layerfolder):
    os.makedirs(layerfolder)

modulesperlayerpernode=[[] for i in range(N)] # a list for each node
# now we go layer by layer
tpfiles.reverse() # hago esto asi queda en el orden adecuado, empezando por el layer 1 (convencion modbp), que tendria index zero
for tpindex in range(number_of_tp_files):
    tpfilename=tpfiles[tpindex]

    # open file with module information
    f=open(tpfilename,"r")
    lines=f.readlines()
    # these files contan an even number of lines: for each pair, the first line indicates module number (which is ordered, from 0) and the second one shows the list of nodes... so we need to take the second line and jump every two lines
    filteredlines=lines[1::2]
    listnodespermodule=[]
    for l in filteredlines:
        q=l.split(" ")[:-1]
        s=map(int,q) # s is a list of node labels (integers)
        listnodespermodule.append(s) 

    listmodulespernode=[[] for i_node in range(N)]
    for i_module in range(len(listnodespermodule)): 
        for i_node in listnodespermodule[i_module]:
            listmodulespernode[i_node].append(i_module)

    for i_node in range(N):
        modulesperlayerpernode[i_node].append(listmodulespernode[i_node])
       
for l in range(number_of_layers):
    f=open(layerbasefilename+"."+str(l+1),'w')
    for i in range(N):
        # what we save here is: for each line (node): 1 if it is contained in more than one module, zero otherwise
        f.write(str(int(len(set(modulesperlayerpernode[i][l])>1))+"\n"))
    f.close()
