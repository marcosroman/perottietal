import random
import glob
import os, os.path
import sys

# solo vamos a tomar como input (argumento) el archivo .edges
# usando eso leemos los tp (en archivo .edges_oslo_files)
# creamos la carpeta  archivo .edges_modbp_files
# y vamos generando los layers.{1,2,...,n} que se guardan ahi
# eso es todo lo que hace este programa, que es central al task

#edgesfilename="tests/example.dat" # esto tengo que cambiar a argv[-1] despues

if len(sys.argv)!=2:
    print "Usage:",sys.argv[0],"<edges file> [assuming <edges file>_oslo_files has already been generated]"
    quit()
else:
    edgesfilename=sys.argv[-1]

tpfolder=edgesfilename+"_oslo_files"
assert os.path.exists(tpfolder)
number_of_tp_files=len(glob.glob(tpfolder+"/tp*"))
# this is the list of the layers, as generated by OSLOM2/oslo_undir
tpfiles=[tpfolder+'/tp']+[tpfolder+'/tp'+str(n) for n in range(1,number_of_tp_files)]

# abro archivo que tiene los links... esto voy a usar para generar una lista de vecinos de cada nodo, que va a ser util mas adelante (para definir a que particion corresponde un nodo, en caso de haber overlaps)
f=open(edgesfilename,"r") # esto no deberia hacer con 'with' mejor? 
lines=f.readlines()
f.close()
while(lines[-1]=='\n'): del(lines[-1]) #saco lineas vacias de abajo
links=[]
for l in lines:
    links.append(map(int,l.split()))
# esto deberia funcionar
#N=max([max(l) for l in links])
N=max([max(l) for l in links])+1 # le agrego el +1, que asume que el conteo de nodos arranca desde el cero
# lista de vecinos, por nodo (esto voy a usar para calcular intersecciones, mas abajo)
neighbors=[[] for i in range(N)]
for i in range(N):
    for l in links:
        #node_label=i+1
        node_label=i
        if(node_label in l):
            auxlist=list(l)
            del(auxlist[auxlist.index(node_label)])
            neighbors[i].append(auxlist[0])
    assert neighbors[i]>0

# ahora creamos la carpeta donde vamos a guardar los outputs (layers, en el formato de modbp, para aprovechar lo que ya tenemos escrito)
layerfolder=edgesfilename+"_oslom2modbp_files"
if not os.path.exists(layerfolder):
    os.makedirs(layerfolder)
# y hacemos la traduccion, al formato de modbp, para cada archivo tb
# (eliminando overlaps, de la forma en la que habiamos convenido antes)
# namely, si un nodo tiene mas de una particion asignada, escoger aquella en la cual tiene mayor cantidad de vecinos (y ahi entra lo de calcular una interseccion entre sets)
for tpindex in range(number_of_tp_files):
    tpfilename=tpfiles[tpindex]
    layernumber=number_of_tp_files-tpindex # se revierte el orden de los indices

    #abrimos archivo con informacion de los modulos
    f=open(tpfilename,"r")
    lines=f.readlines()
    #ignoramos lo que empiece con '#', obtenemos directamente la lista de nodos correspondientes a cada modulo (que, naturalmente, viene ordenada de acuerdo el numero-label del modulo)
    filteredlines=lines[1::2]
    #listnodespermodule=[] # aca encuentro mi error! me falta agregar el primero modulo, al cual van todos los nodos que no tienen asignados un modulo!
    listnodespermodule=[]
    for l in filteredlines:
        q=l.split(" ")[:-1]
        s=map(int,q)
        listnodespermodule.append(s) # le agrego la lista correspondiente al modulo determinado por la linea l
    #listnodespermodule.append([]) # y esto ultimo que agrego es para los que no tienen ningun modulo definido
    #-> al final voy a ir agregando un modulo por nodo huerfano

    listmodulespernode=[[] for i_node in range(N)]
    for i_module in range(len(listnodespermodule)): 
        for node in listnodespermodule[i_module]:
            i_node=node
            listmodulespernode[i_node].append(i_module)
     
    # y aca metemos en la lista los que no tienen modulo predefinido... 
    for i_node in range(N):
        #if (listmodulespernode[i_node]==[]):
        if len(listmodulespernode[i_node])==0:
            listnodespermodule.append([]) # correccion: asi agrego un modulo por cada nodo huerfano
            listnodespermodule[-1].append(i_node)
            listmodulespernode[i_node].append(len(listnodespermodule)-1) # le asignamos el ultimo modulo, recien creado, al huerfano

    # ahora es cuando tengo que recorrer la lista
    # y para aquellos nodos que tengan mas de un nodo asignado
    # calculamos la cantidad de elementos en la interseccion entre sus vecinos y los elementos del nodo en cuestion
    # si hay mas de un modulo que arroje el mismo numero, entonces se escoge aleatoriamente
    finallistmodulespernode=[]
    for i_node in range(N):
        assert len(listmodulespernode[i_node])>=1
        if len(listmodulespernode[i_node])==1:
            finallistmodulespernode.append(listmodulespernode[i_node][0])
        else:
            intersecciones=[] # aca vamos a ir guardando las intersecciones, para escoger, para el nodo con indice i_node, el modulo al cual esta mejor conectado (donde tiene mas vecinos)
            for module in listmodulespernode[i_node]:
                i_module=module
                size_intersection=len(set(neighbors[i_node]).intersection(set(listnodespermodule[i_module])))
                intersecciones.append(size_intersection)
            max_size_intersection=max(intersecciones) 
            # ahora hacemos la lista de los que tienen ese valor en la interseccion
            indices=range(len(listmodulespernode[i_node]))
            bestmodules_indices=filter(lambda x: intersecciones[x]==max_size_intersection, indices)
            if len(bestmodules_indices)==1:
                finallistmodulespernode.append(listmodulespernode[i_node][bestmodules_indices[0]])
            else:
                finallistmodulespernode.append(listmodulespernode[i_node][random.choice(bestmodules_indices)])
        #print i_node,"ok"
    
    # ahora podemos guardar lo obtenido
    fout=open(layerfolder+"/layer."+str(layernumber),'w')
    for i in range(N):
        fout.write(str(finallistmodulespernode[i])+'\n')
    fout.close()

