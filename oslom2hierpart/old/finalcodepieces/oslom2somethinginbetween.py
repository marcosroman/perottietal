import random
import glob
import os, os.path
import sys

# solo vamos a tomar como input (argumento) el archivo .edges
# usando eso leemos los tp (en archivo .edges_oslo_files)
# creamos la carpeta  archivo .edges_modbp_files
# y vamos generando los layers.{1,2,...,n} que se guardan ahi
# eso es todo lo que hace este programa, que es central al task

#edgesfilename="tests/example.dat" # esto tengo que cambiar a argv[-1] despues

if len(sys.argv)!=2:
    print "Usage:",sys.argv[0],"<edges file> [assuming <edges file>_oslo_files has already been generated]"
    quit()
else:
    edgesfilename=sys.argv[-1]

tpfolder=edgesfilename+"_oslo_files"
assert os.path.exists(tpfolder)
number_of_tp_files=len(glob.glob(tpfolder+"/tp*"))
# this is the list of layers, as generated by OSLOM2/oslo_undir
tpfiles=[tpfolder+'/tp']+[tpfolder+'/tp'+str(n) for n in range(1,number_of_tp_files)]

# open net (.edges) file, so that we can arrange a list of neighbors per node. this will be useful (when there are overlaps [one node belonging to more that one module], we will decide the module for each node calculating a few intersectiones between sets [read on])
f=open(edgesfilename,"r") # this could be better (with|try|etc), but it's good enough
lines=f.readlines()
f.close()
while(lines[-1]=='\n'): del(lines[-1]) # remove empty lines, if any
links=[]
for l in lines:
    links.append(map(int,l.split()))
N=max([max(l) for l in links])+1 # +1 since node label are [0:N]
#neighbors, per node
neighbors=[[] for i in range(N)]
for i in range(N):
    for l in links:
        #node_label=i+1
        node_label=i # y esto?
        if(node_label in l):
            auxlist=list(l)
            del(auxlist[auxlist.index(node_label)])
            neighbors[i].append(auxlist[0])
    assert neighbors[i]>0

# create folder where outputs will be saved (in modbp format, to make use of the code we have already written, that takes it to nsp format)
layerfolder=edgesfilename+"_oslom2modbp_files"
if not os.path.exists(layerfolder):
    os.makedirs(layerfolder)

# now we read each tp file and 'translate it' to modbp format.
# there are a few caveats:
#   - oslom may leave some orphan nodes (what belong to no module). to deal with this we can: a) assign to all orphans a new (unique) module, or b) create a new module for each orphan; we decide the latter, as the first option brings some further trouble
#   - there could be overlaps: two (or mode) modules having the same node. in this case, we need to decide just one module per node. to achieve this, we select the module which contains the highest amount of neighbors, for the node whose final module has to be decided. if, among these, more that one options is available, then we choose at random
for tpindex in range(number_of_tp_files):
    tpfilename=tpfiles[tpindex]
    layernumber=number_of_tp_files-tpindex # index number is reversed (just different conventions, between modbp and oslom)

    # open file with module information
    f=open(tpfilename,"r")
    lines=f.readlines()
    # these files contan an even number of lines: for each pair, the first line indicates module number (which is ordered, from 0) and the second one shows the list of nodes... so we need to take the second line and jump every two lines
    filteredlines=lines[1::2]
    listnodespermodule=[]
    for l in filteredlines:
        q=l.split(" ")[:-1]
        s=map(int,q) # s is a list of node labels (integers)
        listnodespermodule.append(s) 

    listmodulespernode=[[] for i_node in range(N)]
    for i_module in range(len(listnodespermodule)): 
        for node in listnodespermodule[i_module]:
            i_node=node
            listmodulespernode[i_node].append(i_module)
     
    # now we deal with orphan nodes
    for i_node in range(N):
        #if (listmodulespernode[i_node]==[]):
        if len(listmodulespernode[i_node])==0:
            listnodespermodule.append([]) # correccion: asi agrego un modulo por cada nodo huerfano
            listnodespermodule[-1].append(i_node)
            listmodulespernode[i_node].append(len(listnodespermodule)-1) # le asignamos el ultimo modulo, recien creado, al huerfano

    # ahora es cuando tengo que recorrer la lista
    # y para aquellos nodos que tengan mas de un nodo asignado
    # calculamos la cantidad de elementos en la interseccion entre sus vecinos y los elementos del nodo en cuestion
    # si hay mas de un modulo que arroje el mismo numero, entonces se escoge aleatoriamente
    finallistmodulespernode=[]
    FORDEBUG_bestmodules_indices_PERNODE=[]
    FORDEBUG_intersecciones_PERNODE=[]
    for i_node in range(N):
        intersecciones=[] # para DEBUG, sacar despues
        bestmodules_indices=[] # para DEBUG, sacar despues
        assert len(listmodulespernode[i_node])>=1
        if len(listmodulespernode[i_node])==1:
            finallistmodulespernode.append(listmodulespernode[i_node][0])
        else:
            intersecciones=[] # aca vamos a ir guardando las intersecciones, para escoger, para el nodo con indice i_node, el modulo al cual esta mejor conectado (donde tiene mas vecinos)
            for module in listmodulespernode[i_node]:
                i_module=module
                size_intersection=len(set(neighbors[i_node]).intersection(set(listnodespermodule[i_module])))
                intersecciones.append(size_intersection)
            max_size_intersection=max(intersecciones) 
            # ahora hacemos la lista de los que tienen ese valor en la interseccion
            indices=range(len(listmodulespernode[i_node]))
            bestmodules_indices=filter(lambda x: intersecciones[x]==max_size_intersection, indices)
            # A LITTLE CHANGE WHEN DEBUGGING
            '''
            if len(bestmodules_indices)==1:
                finallistmodulespernode.append(listmodulespernode[i_node][bestmodules_indices[0]])
            else:
                finallistmodulespernode.append(listmodulespernode[i_node][random.choice(bestmodules_indices)])
            '''
            # instead of the above, just choose the first one
            finallistmodulespernode.append(listmodulespernode[i_node][bestmodules_indices[0]])

        FORDEBUG_bestmodules_indices_PERNODE.append(bestmodules_indices)
        FORDEBUG_intersecciones_PERNODE.append(intersecciones)
        #print i_node,"ok"
    
    # now we can save what we got
    fout=open(layerfolder+"/betweenlayer."+str(layernumber),'w')
    foutDEBUG=open(layerfolder+"/DEBUGbetweenlayer."+str(layernumber),'w')
    for i in range(N):
        #fout.write(str(finallistmodulespernode[i])+'\n')
        for m in listmodulespernode[i]:
            fout.write(str(m)+" ")
        fout.write('\n')
        foutDEBUG.write(str(finallistmodulespernode[i])+'\t'+str(listmodulespernode[i])+'\t'+str(FORDEBUG_intersecciones_PERNODE[i])+'\t'+str(FORDEBUG_bestmodules_indices_PERNODE[i])+'\n')
    fout.close()
    foutDEBUG.close()

